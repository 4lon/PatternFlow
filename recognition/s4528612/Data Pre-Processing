
import re

import tensorflow as tf
import random, os
from tensorflow.keras.preprocessing.image import load_img, img_to_array
import tensorflow.keras as keras
from tensorflow.keras import layers
left = 0
right = 0
labels = []
image_data = []
import os
for dirname, _, filenames in os.walk('/kaggle/input'):
    for filename in filenames:
        if re.search('right', filename.replace("_",""), re.IGNORECASE):
            right += 1
            labels.append(1)
        else:
            left += 1
            labels.append(0)
        image_data.append(img_to_array(load_img(dirname+"/"+filename,
                target_size=(73, 64),
                color_mode="grayscale")))
print(left)
print(right)


#Cross Attention Layer
def cross_attention(image_size):
    
    # Number of Pixels in the Scaled Image
    print(image_size)
    latent_input = layers.Input(shape=(256, 2*(2*6 + 1) + 1))
    data_array_input = layers.Input(shape=(image_size, 2*(2*6 + 1) + 1))

    latent_array = layers.LayerNormalization()(latent_input)
    data_array = layers.LayerNormalization()(data_array_input)

    query_key_value_vector = []
    

    query_key_value_vector.append(layers.Dense(units=2*(2*6 + 1) + 1)(latent_array))
    for _ in range(2):
        query_key_value_vector.append(layers.Dense(units=2*(2*6 + 1) + 1)(data_array))

    attention = layers.Attention(use_scale=True, dropout=0.1)(
        query_key_value_vector
    )
    attention = layers.Add()([attention, latent_array])

    attention = layers.LayerNormalization()(attention)
    
    # Feedforward network.
    feedforward_network = [] # May need to add more layers
    feedforward_network.append(layers.Dense(units=2*(2*6 + 1) + 1))
    outputs = keras.Sequential(feedforward_network)(attention)
    
    outputs = layers.Add()([outputs, attention])

    return keras.Model(inputs=[latent_input,data_array_input], outputs=outputs)

model = cross_attention(73*64, 2*(2*6 + 1) + 1)
model.summary()

#Reshape The Fourier Encoder to The array shape then performe calculation
def fourier_encode(image):
   
    array = tf.cast(tf.expand_dims(array,-1), dtype=tf.float32)
    array_copy = array # Tensors aren't reference types 
    encode = tf.reshape(tf.experimental.numpy.logspace(start=0.0,stop=0.69, num=6, dtype=tf.float32,),(*((1,) * (len(array.shape) - 1)), 6)) 
    array =  3.14 * array * encode
    
    # Repeat the Fourier Encoding For the number of times in the batch and reshape to the correct dimension.
    layer = tf.repeat(tf.reshape(tf.concat((tf.concat([tf.math.sin(array), tf.math.cos(array)], axis=-1),array_copy),axis=-1),
                       (1, image.shape[1], image.shape[2], 2*(2*6+1))), repeats=image.shape[0], axis=0)

    return tf.reshape(tf.concat((image, layer), axis=-1), (image.shape[0], image.shape[1]*image.shape[2], -1)) 
    
def transformer_layer():
    inputs = layers.Input(shape=(256, 27))
    input_normalized = layers.LayerNormalization()(inputs)
    i = 0
    while i < 6:
        input_output_sum = layers.Add()([layers.Dense(27)(attention_component(inputs,input_normalized)[1]), attention_component(inputs,input_normalized)[0]])
        print(i)
        i += 1
    return tf.keras.Model(inputs=inputs, outputs=input_output_sum)

